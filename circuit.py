'''
    This module contains all methods regarding the actual implementation of the circuit and its building blocks.
'''

import numpy as np
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, transpile, Aer

import parse

class DiffuserOp(QuantumCircuit):
    def __init__(self, n):
        super().__init__(n)
        
        self.h(self.qubits)
        self.x(self.qubits)
        self.mcp(np.pi, control_qubits = [q for q in range(n - 1)], target_qubit = n - 1)    
        self.x(self.qubits)
        self.h(self.qubits)
        
        self.name = 'Diffuser'
        self.to_gate()




###############################


def Overall_SAT_Circuit(input_qubits, constraints, iterations):
    '''
        Functionality:
            This functions assembles the building blocks generated by other methods to an overall circuit needed for the given SAT problem.
        Parameters:
            input_qubits (int) - the amount of qubits in the input register.
            constraints (str) - a string that describes a set of boolean arithmetic constraints written in a specific format.
                # A full explanation regarding the format is provided in the file `constraints_format.txt`.
            iterations (int) - number of required iterations over Grover's algorithm.
        Returns:
            (dict) {sat_qc, sat_op}
            sat_qc (QuantumCircuit object) - the overall quantum circuit needed for the SAT problem. Ready to run.
            sat_op (QuantumCircuit object) - the operator generated by the `Grover_SAT_Operator` function.
    '''
    
    # Building blocks
    sat_op = parse.Constraints(constraints, input_qubits)
    diffuser = DiffuserOp(input_qubits)
    
    # Initializing Circuit
    input_reg = QuantumRegister(input_qubits, 'input_reg')
    aux_reg = QuantumRegister(sat_op.total_aux_qubits_needed, 'aux_reg')
    out_reg = QuantumRegister(sat_op.out_qubits_amount, 'out_reg')
    ancilla = QuantumRegister(1, 'ancilla')
    results = ClassicalRegister(input_qubits, 'results')
    sat_qc = QuantumCircuit(input_reg, aux_reg, out_reg, ancilla, results)
    
    # Setting the input register to 2^n = N equal superposition of states, and the ancilla to an eigenstate of the NOT gate: |->
    sat_qc.h(input_reg)
    sat_qc.x(ancilla)
    sat_qc.h(ancilla)
    sat_qc.barrier()
    
    # Applying the iterator (operator + diffuser)
    for i in range(iterations):
        sat_qc.append(sat_op, qargs = sat_qc.qubits)
        sat_qc.append(diffuser, qargs = input_reg)
        sat_qc.barrier()
    
    # Measurements
    sat_qc.measure(input_reg, results)
    
    return {'sat_qc': sat_qc, 'sat_op': sat_op}