
# SAT Circuits Synthesis Engine

This Qiskit-based program builds and runs quantum circuits for satisfiability problems according to user-defined constraints.
The circuits being generated by the program are based on [Grover's algorithm](https://en.wikipedia.org/wiki/Grover%27s_algorithm) and its [amplitude-amplification](https://en.wikipedia.org/wiki/Amplitude_amplification) generalization.


##  Motivation
Today's current quantum software stack is pretty thin.
Quantum programming is being performed mostly at the level of qubits and logic gates.
While for low amounts of qubits it might be sufficient, 
as technology advances and quantum processors scale up, 
it becomes infeasible to design quantum programs for increasing amounts of qubits.
Some adequate layers of abstraction are needed to really exploit the power of future's quantum computers.

Exploiting Grover's and the amplitude-amplification algorithms for SAT-problems solving offers a quadratic speed-up compared to the classical case, assuming the problem has no unique structure (which is analogous to an unsorted database, in the simple database-search problem).
A time complexity of $O(\sqrt{N}$ *up to an oracle* (i.e, $O(\sqrt{N}$ calls to Grover's operator, that is the oracle) is offered by the program, while $N$ is the possible dimension of the solution space (analogous to the size of the database in a simple database-search problem).
The classical solution offers a time complexity of $O(N)$.

## Intention

This program is a proof-of-concept for automatic quantum program synthesis.
While it provides a layer of automation, still many aspects are not covered (yet) by the engine - Such as extensive circuit depth optimization, hardware-aware design, etc.
Grover's algorithm (much like all the other "pure" quantum algorithms - by "pure" I mean not classical-hybrid) is intractable for current NISQ devices, therefore the program relies solely on (noiseless) classical simulators (Qiskit Aer) and is aimed to use on a future fault-tolerant quantum computer.

## Requirements

As detailed in [requirements.txt](requirements.txt):\
`matplotlib==3.6.1`\
`notebook==6.5.1`\
`pylatexenc==2.10`\
`qiskit==0.39.0`

Full dependencies can be found in [pip_freeze.txt](pip_freeze.txt).


## Instructions

1. `git clone https://github.com/ohadlev77/SAT_Circuits_Engine.git.` -> `cd SAT_Circuits_Engine`.
2. If needed - run `pip install -r requirements.txt`.
3. I highly recommend running the program through the `main.ipynb` Jupyter Notebook (`jupyter notebook main.ipynb`) - you'll find there detailed instructions and examples.
4. Running the program through a terminal is possible (though not recommended! graphics are degenerated). By running the following 2 commands an interactive interface will guide you through:
`from interface import SAT`\
`SAT()`
* For more options please run `main.ipynb`.
5. In [test_data.txt](test_data.txt) there are some tested examples that can be used easily, for convenience.
    
## Functionality

### User's Input:

1. The total number of input qubits - $n$ qubits create a $2^n$ search space.
2. A string of boolean arithmetic constraints involving the input qubits (see more in [constraints_format.txt](constraints_format.txt)).
3. The number of `shots` desired.
3. The expected amount of results. If the expected amount of results is unknown, the program can handle this using a variation of the method described in [this paper](https://arxiv.org/abs/quant-ph/9605034) by *Boyer et al.* (section 4). According to the original method once a single solution is obtained then we halt, with the possibility to repeat the process many times. We chose to run a given circuit that yields a solution X times (default X = 10), such that if we obtain solutions in all X times then this circuit might be the optimal circuit or near optimal. Then we run the circuit `shots` times in hope to reveal all solutions.

### The Program's output:
1. A basic representation of the results obtained by running the circuit.
2. A `QuantumCircuit` object representation scheme in 3 layers:
* The overall high-level circuit.
* The high-level operator circuit.
* A low-level operator-circuit.

## Future Improvements Needed

1. Efficiency improvement of the case where the expected number of solutions is unknown (possibly using *weak measurements* technique).
2. Optimization of $MCX$ gates cost.
3. Adding more supported constraints (addition operators between qubits, comparison of qubits and integers, extension to any k-SAT problem, etc).
4. Adding more optimization parameters - Such as maximum amount of qubits available, maximum desired circuit depth, maximum allowed amount of $CX$ gates, etc.